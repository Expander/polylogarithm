// ====================================================================
// This file is part of Polylogarithm.
//
// Polylogarithm is licenced under the MIT License.
// ====================================================================

#include "Cl6.hpp"
#include <cmath>

namespace polylogarithm {

/**
 * @brief Clausen function \f$\operatorname{Cl}_6(\theta) = \operatorname{Im}(\operatorname{Li}_6(e^{i\theta}))\f$
 * @param x real angle
 * @return \f$\operatorname{Cl}_6(\theta)\f$
 * @author Alexander Voigt
 * @note Implemented as a rational function approximation.
 */
double Cl6(double x) noexcept
{
   const double PI = 3.14159265358979324;
   const double PI2 = 2*PI, PIH = PI/2, PI28 = PI*PI/8;
   double sgn = 1;

   if (x < 0) {
      x = -x;
      sgn = -1;
   }

   if (x >= PI2) {
      x = std::fmod(x, PI2);
   }

   if (x > PI) {
      const double p0 = 6.28125;
      const double p1 = 0.0019353071795864769253;
      x = (p0 - x) + p1;
      sgn = -sgn;
   }

   if (x == 0 || x == PI) {
      return 0;
   }

   double h = 0;

   if (x < PIH) {
      const double P[] = {
         1.0369277551433699e+00, -2.087195444107175e-01,
         2.0652251045312954e-02, -1.383438138256840e-04
      };
      const double Q[] = {
         1.0000000000000000e+00, -8.0784096827362542e-03,
         5.8074568862993102e-06, -5.1960620033050114e-10
      };
      const double y = x*x;
      const double y2 = y*y;
      const double p = P[0] + y * P[1] + y2 * (P[2] + y * P[3]);
      const double q = Q[0] + y * Q[1] + y2 * (Q[2] + y * Q[3]);
      h = x*(p/q - 1./120*y2*std::log(x));
   } else {
      const double P[] = {
         7.9544504578027050e-01, -1.9255025309738589e-01,
         1.5805208288846591e-02, -5.4175380521534706e-04,
         6.7577493541009068e-06
      };
      const double Q[] = {
         1.0000000000000000e+00, -7.0798422394109274e-02,
         7.1744189715634762e-04,  3.9098747334347093e-06,
         3.5669441618295266e-08,  2.5315391843409925e-10
      };
      const double y = PI - x;
      const double z = y*y - PI28;
      const double z2 = z*z;
      const double z4 = z2*z2;
      const double p = P[0] + z * P[1] + z2 * (P[2] + z * P[3]) +
         z4 * P[4];
      const double q = Q[0] + z * Q[1] + z2 * (Q[2] + z * Q[3]) +
         z4 * (Q[4] + z * Q[5]);
      h = y*p/q;
   }

   return sgn*h;
}

/**
 * @brief Clausen function \f$\operatorname{Cl}_6(\theta) = \operatorname{Im}(\operatorname{Li}_6(e^{i\theta}))\f$ with long double precision
 * @param x real angle
 * @return \f$\operatorname{Cl}_6(\theta)\f$
 * @author Alexander Voigt
 * @note Implemented as a rational function approximation.
 */
long double Cl6(long double x) noexcept
{
   const long double PI = 3.14159265358979323846264338327950288L;
   const long double PI2 = 2*PI, PIH = PI/2, PI28 = PI*PI/8;
   long double sgn = 1;

   if (x < 0) {
      x = -x;
      sgn = -1;
   }

   if (x >= PI2) {
      x = std::fmod(x, PI2);
   }

   if (x > PI) {
      const long double p0 = 6.28125L;
      const long double p1 = 0.0019353071795864769252867665590057683943L;
      x = (p0 - x) + p1;
      sgn = -sgn;
   }

   if (x == 0 || x == PI) {
      return 0;
   }

   long double h = 0;

   if (x < PIH) {
      const long double P[] = {
          1.036927755143369926331365486457034168065e+00L,
         -2.660560946045374649259428347964066528011e-01L,
          3.329570271230632447915886341952627002426e-02L,
         -1.510595936295153930344410647448777133733e-03L,
          3.131533341760691526435978423292286070924e-05L,
         -3.182202696889770889861949924913754657738e-07L,
          1.502154861660275591001686250751888925088e-09L,
         -2.530301425170917471647697924032269884340e-12L
      };
      const long double Q[] = {
          1.000000000000000000000000000000000000000e+00L,
         -6.337305283354669272645114902626308743354e-02L,
          1.515620531828504731765511986731389626117e-03L,
         -1.701012841394302177981550973231789765121e-05L,
          9.012790948792709615665799862069582273389e-08L,
         -1.955750290547090446555264920849355913809e-10L,
          1.125635205633553699806475976092388993586e-13L,
         -3.414909518610593288941467030106839852619e-17L,
          2.731334891221423274951783991445121711509e-20L
      };
      const long double y = x*x;
      const long double y2 = y*y;
      const long double y4 = y2*y2;
      const long double y8 = y4*y4;
      const long double p = P[0] + y * P[1] + y2 * (P[2] + y * P[3]) +
         y4 * (P[4] + y * P[5] + y2 * (P[6] + y * P[7]));
      const long double q = Q[0] + y * Q[1] + y2 * (Q[2] + y * Q[3]) +
         y4 * (Q[4] + y * Q[5] + y2 * (Q[6] + y * Q[7])) + y8 * Q[8];
      h = x*(p/q - 1.0L/120*y2*std::log(x));
   } else {
      const long double P[] = {
          7.954450457802705032518570844852029808415e-01L,
         -1.979654488543484542796423982466857472184e+00L,
          2.434867838946397357375315454192170616124e+00L,
         -1.964425998279360367244413531701686788004e+00L,
          1.163493279389496220127087149386609481819e+00L,
         -5.364077005864988957572986042062186039135e-01L,
          1.991451450604170643782194918551652235412e-01L,
         -6.075285910357297275594322567072299864962e-02L,
          1.540382986766113987053539678403427170024e-02L,
         -3.262283827598416962628772540178344338003e-03L,
          5.770138838748397202025797274794204575025e-04L,
         -8.484414959829259817085085809443855753227e-05L,
          1.028090385459798495867863677951863946204e-05L,
         -1.013685169455150840547824060456243954836e-06L,
          7.999945234418244274075829768407844359782e-08L,
         -4.952891486250932501218801565751739529817e-09L,
          2.348815233867171539009806063660356488830e-10L,
         -8.290157415183592261669982284003187521338e-12L,
          2.099356902503040843690329973355214193519e-13L,
         -3.624780995036058134427748307780059725260e-15L,
          3.942847910228622725482057878552182375210e-17L,
         -2.345906560814244916985213074113978675514e-19L,
          5.497397893599040802663932665275542828208e-22L
      };
      const long double Q[] = {
          1.000000000000000000000000000000000000000e+00L,
         -2.317470577719543024485753572740604958739e+00L,
          2.657078821297694611895446031834996152906e+00L,
         -1.998173132007341993679896448865948292346e+00L,
          1.101652499108299120694677562656808297062e+00L,
         -4.714605359562262375267465521671001054303e-01L,
          1.617420872947402588595250105881596491551e-01L,
         -4.529168129075646577813431788905728209674e-02L,
          1.044157981053687467828669325295558925061e-02L,
         -1.984415953027051010511439725524140293510e-03L,
          3.093087663153734127422305801345643761966e-04L,
         -3.908979880746900739955710393100816436543e-05L,
          3.932920430793276196786510478170661211424e-06L,
         -3.069947838220881985252402565106441299447e-07L,
          1.796593245006812188327588557650112423621e-08L,
         -7.547660787922061824124166989056610198020e-10L,
          2.154298038494995924762486242481055338867e-11L,
         -3.878728177963117873055418445714408964957e-13L,
          3.933225726003866890018525083062372496392e-15L,
         -1.816273280755794317176857308245737055922e-17L,
          1.999376255104830360180352396370413061880e-20L,
          1.409076511280851323909957285090860978867e-23L,
          1.442619469440665628791395058095914522784e-26L
      };
      const long double y = PI - x;
      const long double z = y*y - PI28;
      const long double z2 = z*z;
      const long double z4 = z2*z2;
      const long double z8 = z4*z4;
      const long double z16 = z8*z8;
      const long double p = P[0] + z*P[1] + z2*(P[2] + z*P[3]) +
         z4*(P[4] + z*P[5] + z2*(P[6] + z*P[7])) +
         z8*(P[8] + z*P[9] + z2*(P[10] + z*P[11]) +
             z4*(P[12] + z*P[13] + z2*(P[14] + z*P[15]))) +
         z16*(P[16] + z*P[17] + z2*(P[18] + z*P[19]) +
              z4*(P[20] + z*P[21] + z2*P[22]));
      const long double q = Q[0] + z*Q[1] + z2*(Q[2] + z*Q[3]) +
         z4*(Q[4] + z*Q[5] + z2*(Q[6] + z*Q[7])) +
         z8*(Q[8] + z*Q[9] + z2*(Q[10] + z*Q[11]) +
             z4*(Q[12] + z*Q[13] + z2*(Q[14] + z*Q[15]))) +
         z16*(Q[16] + z*Q[17] + z2*(Q[18] + z*Q[19]) +
              z4*(Q[20] + z*Q[21] + z2*Q[22]));
      h = y*p/q;
   }

   return sgn*h;
}

} // namespace polylogarithm
