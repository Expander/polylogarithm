// ====================================================================
// This file is part of Polylogarithm.
//
// Polylogarithm is licenced under the MIT License.
// ====================================================================

#include "Cl5.hpp"
#include <cmath>

namespace polylogarithm {

/**
 * @brief Clausen function \f$\operatorname{Cl}_5(\theta) = \operatorname{Re}(\operatorname{Li}_5(e^{i\theta}))\f$
 * @param x real angle
 * @return \f$\operatorname{Cl}_5(\theta)\f$
 * @author Alexander Voigt
 * @note Implementation as rational function approximation.
 */
double Cl5(double x) noexcept
{
   const double PI = 3.14159265358979324;
   const double PI2 = 2*PI, PIH = PI/2, PI28 = PI*PI/8;
   const double zeta5 = 1.0369277551433699;

   if (x < 0) {
      x = -x;
   }

   if (x >= PI2) {
      x = std::fmod(x, PI2);
   }

   if (x > PI) {
      const double p0 = 6.28125;
      const double p1 = 0.0019353071795864769253;
      x = (p0 - x) + p1;
   }

   if (x == 0) {
      return zeta5;
   }

   double h = 0;

   if (x < PIH) {
      const double P[] = {
         1.0369277551433699e+00, -6.1354800479984468e-01,
         9.4076401395712763e-02, -9.4056155866704436e-04
      };
      const double Q[] = {
         1.0000000000000000e+00, -1.2073698633244778e-02,
         1.3703409625482991e-05, -1.9701280330628469e-09,
         2.1944550184416500e-11
      };
      const double y = x*x;
      const double y2 = y*y;
      const double p = P[0] + y * P[1] + y2 * (P[2] + y * P[3]);
      const double q = Q[0] + y * Q[1] + y2 * (Q[2] + y * Q[3] + y2 * Q[4]);
      h = p/q - 1./24*y2*std::log(x);
   } else {
      const double P[] = {
         -4.5930112735784898e-01, 4.3720705508867954e-01,
         -7.5895226486465095e-02, 5.2244176912488065e-03,
         -1.5677716622013956e-04, 1.6641624171748576e-06
      };
      const double Q[] = {
          1.0000000000000000e+00, -1.2211486825401188e-01,
          3.8940070749313620e-03, -2.2674805547074318e-05,
         -7.4383354448335299e-08, -3.4131758392216437e-10
      };
      const double y = PI - x;
      const double z = y*y - PI28;
      const double z2 = z*z;
      const double z4 = z2*z2;
      const double p = P[0] + z * P[1] + z2 * (P[2] + z * P[3]) +
         z4 * (P[4] + z * P[5]);
      const double q = Q[0] + z * Q[1] + z2 * (Q[2] + z * Q[3]) +
         z4 * (Q[4] + z * Q[5]);
      h = p/q;
   }

   return h;
}

/**
 * @brief Clausen function \f$\operatorname{Cl}_5(\theta) = \operatorname{Re}(\operatorname{Li}_5(e^{i\theta}))\f$ with long double precision
 * @param x real angle
 * @return \f$\operatorname{Cl}_5(\theta)\f$
 * @author Alexander Voigt
 * @note Implementation as a rational function approximation.
 */
long double Cl5(long double x) noexcept
{
   const long double PI = 3.14159265358979323846264338327950288L;
   const long double PI2 = 2*PI, PIH = PI/2, PI28 = PI*PI/8;
   const long double zeta5 = 1.036927755143369926331365486457034168057L;

   if (x < 0) {
      x = -x;
   }

   if (x >= PI2) {
      x = std::fmod(x, PI2);
   }

   if (x > PI) {
      const long double p0 = 6.28125L;
      const long double p1 = 0.0019353071795864769252867665590057683943L;
      x = (p0 - x) + p1;
   }

   if (x == 0) {
      return zeta5;
   }

   long double h = 0;

   if (x < PIH) {
      const long double P[] = {
          1.036927755143369926331365486457034168059e+00L,
         -6.658415657850437630906494266561003007593e-01L,
          1.259003016280956661310195617144355854188e-01L,
         -6.212244855421374019684377914106722032147e-03L,
          1.306904675086766776780752497454855872743e-04L,
         -1.301122318938781794973397940423670888074e-06L,
          5.717682046130944699740232163126766430315e-09L,
         -7.166730647779603072734193853044478650519e-12L,
         -6.221283541257953085130453147995995181367e-15L
      };
      const long double Q[] = {
           1.000000000000000000000000000000000000000e+00L,
          -6.250494683333583907004116232413530782665e-02L,
           1.473096513856482450087316982512306280017e-03L,
          -1.623646824927319203504705952432918456484e-05L,
           8.353119806924927286335397331658035078824e-08L,
          -1.681466989589289789440503472880056217026e-10L,
           6.148805322164900432117190884093933333085e-14L,
          -5.433659481969077686644650549730628882111e-18L,
           2.805294177992899924191150639021652374105e-20L
      };
      const long double y = x*x;
      const long double y2 = y*y;
      const long double y4 = y2*y2;
      const long double y8 = y4*y4;
      const long double p = P[0] + y * P[1] + y2 * (P[2] + y * P[3]) +
         y4 * (P[4] + y * P[5] + y2 * (P[6] + y * P[7])) + y8 * P[8];
      const long double q = Q[0] + y * Q[1] + y2 * (Q[2] + y * Q[3]) +
         y4 * (Q[4] + y * Q[5] + y2 * (Q[6] + y * Q[7])) + y8 * Q[8];
      h = p/q - 1.0L/24*y2*std::log(x);
   } else {
      const long double P[] = {
         -4.593011273578489831122037919180632756992e-01L,
          1.401498550034362701805821755409735004849e+00L,
         -1.982304363064711766557880680480142023754e+00L,
          1.759256162035262108299985791199116650552e+00L,
         -1.107291973389099556880709229657630417009e+00L,
          5.268325404326907430154018183034221801285e-01L,
         -1.965358651607522994714557697339746608190e-01L,
          5.871957972979889275145683305566978199622e-02L,
         -1.420949697005558567627555469736533751386e-02L,
          2.796107583559495331461649354270877844625e-03L,
         -4.465744740639093809792128449171996370363e-04L,
          5.748894292163274399653883756491192329322e-05L,
         -5.896839706071169994406762984593861583644e-06L,
          4.744162040470895539630087398826359252082e-07L,
         -2.935072474912184831415614463651445914914e-08L,
          1.362917540308020844217793474829589045233e-09L,
         -4.607334782488962303281676898176385641774e-11L,
          1.088416571921417630560594614106156147693e-12L,
         -1.693492466827010829186922354118958201170e-14L,
          1.579743944918170026644416986681028224058e-16L,
         -7.454416400034827845657507019398034188457e-19L,
          1.198637161245584739862544324830094607612e-21L
      };
      const long double Q[] = {
           1.000000000000000000000000000000000000000e+00L,
          -2.221590435607426981424381339809382952069e+00L,
           2.412461871413914536986570795505245816684e+00L,
          -1.694345897219170542301900522084726731706e+00L,
           8.583400353918575152767736792978326398967e-01L,
          -3.312119064957463423272973014087119757079e-01L,
           1.002294898527499697641480925721728343179e-01L,
          -2.413139952253300495006378204579804376275e-02L,
           4.641991091392426345416434800383383313512e-03L,
          -7.106571006177041202150584409076882380159e-04L,
           8.561490223086549530320523664905653696096e-05L,
          -7.967787445964202721461699361010303143885e-06L,
           5.582421743796253821134150677212091680429e-07L,
          -2.848005320309192458445894966140050403870e-08L,
           1.014286757743366612938336036904920512828e-09L,
          -2.385238633505776782528334863036613070815e-11L,
           3.420301781310778564389954330829757801274e-13L,
          -2.629398993349212252716804572483435975360e-15L,
           8.429482185232205831230867081060289901658e-18L,
          -5.246319511505491796737303878146128855864e-21L,
          -7.761839321681147483054193372291436641588e-25L,
           2.417533650811564066454166411668509913721e-27L
      };
      const long double y = PI - x;
      const long double z = y*y - PI28;
      const long double z2 = z*z;
      const long double z4 = z2*z2;
      const long double z8 = z4*z4;
      const long double z16 = z8*z8;
      const long double p = P[0] + z*P[1] + z2*(P[2] + z*P[3]) +
         z4*(P[4] + z*P[5] + z2*(P[6] + z*P[7])) +
         z8*(P[8] + z*P[9] + z2*(P[10] + z*P[11]) +
             z4*(P[12] + z*P[13] + z2*(P[14] + z*P[15]))) +
         z16*(P[16] + z*P[17] + z2*(P[18] + z*P[19]) +
              z4*(P[20] + z*P[21]));
      const long double q = Q[0] + z*Q[1] + z2*(Q[2] + z*Q[3]) +
         z4*(Q[4] + z*Q[5] + z2*(Q[6] + z*Q[7])) +
         z8*(Q[8] + z*Q[9] + z2*(Q[10] + z*Q[11]) +
             z4*(Q[12] + z*Q[13] + z2*(Q[14] + z*Q[15]))) +
         z16*(Q[16] + z*Q[17] + z2*(Q[18] + z*Q[19]) +
              z4*(Q[20] + z*Q[21]));
      h = p/q;
   }

   return h;
}

} // namespace polylogarithm
